# Unix RPC + Notification Framework

## Formal Engineering Specification (v3.0)

Status: Draft\
Target Platform: Linux (primary), macOS (planned)\
Language: C++ (primary), Python (bindings)

------------------------------------------------------------------------

# 1. Terminology

The key words **MUST**, **SHALL**, **SHOULD**, and **MAY** are to be
interpreted as described in RFC 2119.

------------------------------------------------------------------------

# 2. System Overview

The framework consists of two subsystems:

1.  **RunLoop Runtime Library**
2.  **Service Toolchain (IDL + Code Generation)**

The runtime provides IPC transport, dispatching, shared memory support,
and lifecycle management.

The toolchain provides type-safe RPC stubs and notification glue
generated from IDL.

------------------------------------------------------------------------

# 3. Design Decisions

The following decisions were made during the design phase:

### 3.1 Target Platform

-   Primary target is **Linux**. macOS support is planned.
-   Platform-specific APIs SHALL be wrapped behind abstractions:
    -   Shared memory: `memfd_create` (Linux) / `shm_open` (macOS)
    -   Socket type: `SOCK_SEQPACKET` (Linux) / `SOCK_STREAM` (macOS)
    -   Event loop: `epoll` (Linux) / `kqueue` (macOS)
-   Initial implementation targets Linux. macOS backend will be added
    later behind the same interfaces.

### 3.2 Serialization

-   The framework SHALL use **hand-rolled serialization** generated by
    the code generator. No external serialization library (protobuf,
    FlatBuffers, etc.) is used.
-   Rationale:
    -   Payload types are simple (POD, fixed-size structs, arrays,
        bounded strings). `memcpy` + length prefixes are sufficient.
    -   Using protobuf would introduce a second IDL (`.proto`) alongside
        our own, adding unnecessary complexity.
    -   Protobuf's serialize/deserialize cycle conflicts with the
        shared-memory zero-copy fast-path.
    -   No external dependency is required.

### 3.3 Endianness

-   Wire format SHALL be **little-endian**.
-   Implementation SHALL use `htole16`/`le16toh`, `htole32`/`le32toh`
    from `<endian.h>` for encoding/decoding multi-byte integers.
-   On x86_64 and aarch64 (all realistic Linux/macOS targets), these
    are no-ops at zero cost.
-   This keeps the wire format deterministic and debuggable.

### 3.4 Transport Architecture

The framework uses a **split transport**:

-   **Shared memory** for ALL data transfer. Both message headers and
    payloads (small and large) are written to a shared memory region.
    No data flows through the socket.
-   **Unix Domain Sockets** for signaling only:
    -   Connection establishment and peer discovery.
    -   "Message ready" wakeup notifications.
    -   Crash detection (broken pipe).
    -   Initial FD exchange to set up the shared memory region.

Rationale:

-   Shared memory provides zero-copy data transfer for all message
    sizes. The writer writes directly into memory the reader can access.
-   UDS provides connection lifecycle and crash detection for free
    from the OS, without carrying any payload data.
-   Clean separation: UDS is the control plane, shared memory is
    the data plane.

### 3.5 RunLoop as Pure Event Loop

-   The RunLoop SHALL be a **pure event loop**. It does not know about
    RPC, services, connections, or transport.
-   Connection setup (UDS socket creation, shared memory allocation,
    handshake) is handled by the **generated service layer**:
    -   Server side: `Service::Create()` creates the endpoint.
    -   Client side: `client.connect()` connects to the endpoint.
-   The RunLoop only runs the event loop and executes posted callables.
-   Higher-level classes (Service, Client) post their work to the
    RunLoop via `runOnThread()`.

### 3.6 Multi-Client Architecture

-   The framework SHALL support **multiple clients** connecting to a
    single server.
-   Each client-server connection is **fully isolated**:
    -   Each connection has its own UDS socket.
    -   Each connection has its own shared memory region with its own
        pair of ring buffers.
    -   No shared state exists between connections.
-   The server-side Service class SHALL manage multiple connections
    internally, using `epoll`/`kqueue` to multiplex across all client
    UDS file descriptors.
-   A misbehaving or crashing client SHALL only affect its own
    connection. Other clients SHALL be unaffected.
-   Notifications SHALL be delivered per-connection. When the server
    sends a notification, it SHALL be sent to all connected clients
    (or a targeted subset, depending on the generated service layer).

------------------------------------------------------------------------

# 4. RunLoop Specification

## 4.1 Responsibilities

The RunLoop SHALL:

1.  Provide a generic event loop on a dedicated thread.
2.  Allow other components to post work to that thread.
3.  Provide deterministic stop semantics.

The RunLoop does NOT:

-   Know about RPC, notifications, services, or frame formats.
-   Manage connections, sockets, or shared memory.

------------------------------------------------------------------------

## 4.2 Public API (Required)

``` cpp
class RunLoop
{
public:
    void init(const char* name);
    void run();
    void stop();
    void runOnThread(std::function<void()> fn);
};
```

### Behavioral Requirements

-   `init(name)` SHALL initialize the event loop (create the epoll
    instance and internal wakeup mechanism). `name` identifies the
    run loop for debugging/logging purposes.
-   `run()` SHALL block the calling thread, executing posted
    callables until `stop()` is invoked.
-   `stop()` SHALL:
    -   Terminate the run loop
    -   Be thread-safe — callable from any thread or from within
        a posted callable
-   `runOnThread(fn)` SHALL:
    -   Accept a callable and execute it on the run loop thread
    -   Be thread-safe — callable from any thread
    -   Wake the run loop so the callable is processed promptly

### Error Codes

Framework error codes are negative. User/service codes are zero or
positive. No collision between the two ranges.

``` cpp
enum RpcError {
    RPC_SUCCESS             =  0,
    RPC_ERR_DISCONNECTED    = -1,  // peer died or connection lost
    RPC_ERR_TIMEOUT         = -2,  // no response received in time
    RPC_ERR_INVALID_SERVICE = -3,  // serviceId not found
    RPC_ERR_INVALID_METHOD  = -4,  // methodId not found
    RPC_ERR_VERSION_MISMATCH= -5,  // protocol version incompatible
    RPC_ERR_RING_FULL       = -6,  // ring buffer full, try again
    RPC_ERR_STOPPED         = -7,  // dispatcher stopped while call pending
};
// User handler returns: 0 = success, >0 = service-specific error
```

### Ring Buffer Sizing

-   Default ring buffer size: **256 KB** per direction (512 KB total
    per connection).
-   Size SHALL be a power of 2 (enables bitmask wraparound).
-   Compile-time constant for initial implementation.

------------------------------------------------------------------------

## 4.3 Transport Requirements

### 4.3.1 UDS (Signaling Only)

-   Transport SHALL use Unix Domain Sockets for signaling.
-   Linux: SHALL use `SOCK_SEQPACKET`.
-   macOS (future): SHALL use `SOCK_STREAM`.
-   UDS SHALL NOT carry message payloads. It carries only:
    -   Connection handshake
    -   Shared memory FD exchange (via `SCM_RIGHTS`) during connection
    -   Lightweight "message ready" signals
-   The dispatch loop SHALL use `epoll` (Linux) / `kqueue` (macOS)
    to wait on the UDS for incoming signals.

### 4.3.2 Connection Handshake Protocol

`Service::Create()` (server side):

1.  Create UDS socket.
    -   Linux: `SOCK_SEQPACKET`
    -   macOS (future): `SOCK_STREAM` <!-- MACOS_BOOKMARK -->
2.  Bind to endpoint path derived from service name.
    -   Linux: abstract namespace `\0rpc_<serviceName>`
    -   macOS (future): filesystem path (abstract namespace not
        supported) <!-- MACOS_BOOKMARK -->
3.  Listen. Return — server is ready to accept clients.

`client.connect()` (client side):

1.  Try `connect()` to the endpoint path.
    -   If `ECONNREFUSED` or `ENOENT`, retry with backoff until server
        appears or `stop()` is invoked.
2.  UDS connection established.
3.  Client creates shared memory region:
    -   Linux: `memfd_create` + `ftruncate`
    -   macOS (future): `shm_open` + `ftruncate` +
        `shm_unlink` <!-- MACOS_BOOKMARK -->
4.  Client sends over UDS: protocol version (u16) + shared memory FD
    (via `SCM_RIGHTS`).
5.  Server receives: validates protocol version, `mmap`s the shared
    memory FD.
6.  Server sends back: ACK (version OK) or NACK (version mismatch,
    connection refused).
7.  Both peers now have the ring buffers mapped.
8.  Server adds this connection's UDS fd to `epoll`/`kqueue`.
9.  `client.connect()` returns — connection is live.

### 4.3.3 Shared Memory (Data Plane)

-   The client creates and owns the shared memory region. The FD is
    passed to the server during the handshake (section 4.3.2).
-   Both peers SHALL `mmap` the shared region.
-   ALL message data (headers and payloads) SHALL be written to and
    read from shared memory. No data passes through the socket.

### 4.3.3 Shared Memory Layout

The shared memory region SHALL contain a ring buffer for each
direction of communication (two ring buffers total):

-   **Peer A -> Peer B ring buffer**
-   **Peer B -> Peer A ring buffer**

Each ring buffer SHALL have:

-   A write offset (updated by the writer)
-   A read offset (updated by the reader)
-   A data region for message frames

Messages in the ring buffer consist of the frame header followed
immediately by the payload bytes. Implementation details (ring
buffer size, wraparound handling, flow control) are deferred to
implementation.

------------------------------------------------------------------------

## 4.4 Frame Format (Normative)

All multi-byte integers SHALL be little-endian, encoded/decoded using
`<endian.h>` conversion functions.

### 4.4.1 Header Layout

  Offset   Field          Type   Size
  -------- -------------- ------ ------
  0        version        u16    2
  2        flags          u16    2
  4        serviceId      u32    4
  8        messageId      u32    4
  12       seq            u32    4
  16       payloadBytes   u32    4
  20       aux            u32    4

Total header size: 24 bytes

### 4.4.2 Flags

  Flag       Value
  ---------- --------
  Request    0x0001
  Response   0x0002
  Notify     0x0004

------------------------------------------------------------------------

## 4.5 Message Flow

### 4.5.1 Sending a Message

1.  Writer marshals the frame (header + payload) into the shared
    memory ring buffer.
2.  Writer sends a lightweight signal over UDS to wake the reader.

### 4.5.2 Receiving a Message

1.  Reader is woken by `epoll`/`kqueue` on the UDS signal.
2.  Reader reads the frame directly from shared memory.
3.  Reader advances the read offset.

### 4.5.3 RPC Flow

Caller Thread:

    call()
      -> marshal request into shared memory ring buffer
      -> signal peer via UDS
      -> wait on condition_variable

Dispatcher Thread:

    woken by UDS signal
      -> read request from shared memory
      -> invoke handler
      -> marshal response into shared memory ring buffer
      -> signal peer via UDS

    woken by UDS signal
      -> read response from shared memory
      -> match seq
      -> signal waiting caller

### 4.5.4 Notification Flow

Notifications are **fire-and-forget** (no response, no seq correlation)
and **broadcast** to all connected clients.

Server application code:

    impl.notifyDiskAdded(diskInfo);   // calls generated method

Generated skeleton (notifyDiskAdded):

    marshal DiskInfo into payload
    for each connected client:
      -> write Notify frame (serviceId, notifyId=0, payload)
         to that client's ring buffer
      -> send wakeup signal on that client's UDS

Client dispatcher thread:

    woken by UDS signal
      -> read frame from shared memory, sees Notify flag
      -> calls client.handleMessage(notifyId=0, payload)
      -> handleMessage switch/cases on notifyId
      -> calls onDiskAdded(info)
      -> user's override runs

### 4.5.5 End-to-End Sequence Diagram

Full lifecycle: service creation, client connection, RPC call,
notification, and shutdown.

```
  SERVER APP                    FRAMEWORK                    CLIENT APP
  ==========                    =========                    ==========

  -- Startup --

  RunLoop dispatcher
  MyStorageService impl
    ("StorageService",
     &dispatcher)
                          Service::Create()
                            create UDS socket
                            bind \0rpc_StorageService
                            listen
                            return
                                |
  dispatcher.run()              |
    [blocks on epoll]           |
                                |
                                |                    RunLoop dispatcher
                                |                    MyStorageClient client
                                |                      ("StorageService",
                                |                       &dispatcher)
                                |
                                |                    client.connect()
                                |                      connect() to UDS
                          accept() <------ UDS ------  |
                                |                      create memfd
                                |                      ftruncate (512KB)
                          recv version + FD <---UDS--- send version + FD
                            validate version           |
                            mmap shared memory         |
                          send ACK ----------UDS--->   recv ACK
                            add fd to epoll            mmap shared memory
                                |                      connect() returns
                                |
                                |                    thread t { dispatcher.run() }
                                |                      [blocks on epoll]

  -- RPC Call: GetDiskCount --
                                |
                                |                    client.GetDiskCount(&count)
                                |                      marshal request
                                |                      write to shmem ring buf
                          epoll wakes <----UDS----     signal server UDS
                            read from shmem            wait on condvar
                            handleMessage(0, ...)      |
                            handleGetDiskCount()       |
                            impl returns 0, count=5    |
                            marshal response           |
                            write to shmem ring buf    |
                          signal client UDS --UDS--->  epoll wakes
                                |                      read from shmem
                                |                      match seq, signal condvar
                                |                      unmarshal: count=5
                                |                      return 0

  -- Notification: DiskAdded --

  impl.notifyDiskAdded(info)
    generated code:
      marshal DiskInfo
      write Notify frame
        to client's ring buf
    signal client UDS ------UDS--->  epoll wakes
                                |    read from shmem, sees Notify
                                |    handleMessage(notifyId=0, ...)
                                |    onDiskAdded(info)
                                |    user override runs

  -- Shutdown --
                                |
                                |                    dispatcher.stop()
                                |                      close UDS
  epoll: broken pipe            |                      complete pending calls
  cleanup connection            |                    t.join()
  dispatcher.stop()             |
  dispatcher.run() returns      |
  exit                          |                    exit
```

------------------------------------------------------------------------

# 5. Serialization Specification

## 5.1 Encoding Rules

The code generator SHALL emit marshal/unmarshal functions using
the following encoding:

-   **POD scalars** (u8, u16, u32, u64, i8, i16, i32, i64, float,
    double): written directly using `memcpy`, with `htoleXX`/`leXXtoh`
    for multi-byte integers.
-   **Enums**: cast to underlying integer type and encoded as scalar.
-   **Fixed-size structs**: encoded field-by-field (not raw `memcpy` of
    the struct, to avoid padding/alignment issues).
-   **Bounded strings**: u32 length prefix followed by UTF-8 bytes (no
    null terminator on wire).
-   **Arrays**: u32 count prefix followed by sequential elements.
-   **Bulk data**: transferred via shared memory, not serialized.

## 5.2 No External Dependencies

-   No protobuf, FlatBuffers, Cap'n Proto, or similar library SHALL be
    used.
-   All marshalling code SHALL be emitted by the code generator.

------------------------------------------------------------------------

# 6. IDL Specification

## 6.1 Supported Constructs

-   service
-   notifications
-   enum
-   struct
-   primitive types
-   bounded string
-   typedef
-   method attributes
-   parameter attributes

## 6.2 Built-in Primitive Types

IDL type names are **language-agnostic**. The code generator maps them
to the target language. Users MAY define shorter aliases via `typedef`.

  IDL type     C++ mapping       Size (bytes)
  ------------ ----------------- ------------
  uint8        uint8_t           1
  uint16       uint16_t          2
  uint32       uint32_t          4
  uint64       uint64_t          8
  int8         int8_t            1
  int16        int16_t           2
  int32        int32_t           4
  int64        int64_t           8
  float32      float             4
  float64      double            8
  bool         bool              1
  string       char[] (bounded)  variable

-   `string` SHALL always have a `[maxChars=N]` bound in struct fields.
-   The code generator SHALL resolve all `typedef` aliases before
    emitting target language code.

------------------------------------------------------------------------

## 6.3 IDL EBNF Grammar (Formal)

    file            = { declaration } ;

    declaration     = serviceDecl
                    | notificationsDecl
                    | structDecl
                    | enumDecl
                    | typedefDecl ;

    serviceDecl     = "service" identifier "{" { methodDecl } "}" ;

    notificationsDecl = "notifications" identifier
                        "{" { notifyDecl } "}" ;

    methodDecl      = attributeBlock "int" identifier
                      "(" [ paramList ] ")" ";" ;

    notifyDecl      = attributeBlock "void" identifier
                      "(" [ paramList ] ")" ";" ;

    paramList       = param { "," param } ;

    param           = attributeBlock type pointerOpt identifier arrayLenOpt ;

    attributeBlock  = "[" attribute { "," attribute } "]" ;

    attribute       = identifier "=" literal
                    | identifier ;

    arrayLenOpt     = "[" "len" "=" identifier "]" | empty ;

    pointerOpt      = "*" | empty ;

    structDecl      = "struct" identifier
                      "{" { structField } "}" ";" ;

    structField     = type identifier stringBoundOpt ";" ;

    stringBoundOpt  = "[" "maxChars" "=" number "]"
                    | empty ;

    enumDecl        = "enum" identifier ":" type
                      "{" { enumEntry } "}" ";" ;

    enumEntry       = identifier "=" number "," ;

    type            = identifier ;

    identifier      = letter { letter | digit | "_" } ;
    number          = digit { digit } ;

------------------------------------------------------------------------
## 6.4 IDL Example:
```
[package="platform.storage"]
[version=1]
[serviceId=42]              // optional, but common

typedef uint32 u32;
typedef uint64 u64;
typedef int32  i32;
type string;

enum DiskState : u32
{
    Unknown=0, Unformatted=1, Formatted=2, Mounted=3, Unmounted=4
};

struct DiskId
{
    u32 value;
};

struct DiskInfo
{
    DiskId    id;
    DiskState state;
    u64       capacityBytes;
    string    name      [maxChars=64];
    string    mountPath [maxChars=128];
};

service StorageService
{
    [method=0]
    int GetDiskCount([out] u32* count);

    // Two-phase: client allocates 'capacity' entries.
    // Runtime may map client buffer into server process.
    [method=1]
    int GetDisks(
        [in]  u32 capacity,
        [out] DiskInfo* disks [len=capacity],
        [out] u32* count);
};

notifications StorageService
{
    [notify=0]
    void DiskAdded([in] DiskInfo info);

    [notify=1]
    void DiskRemoved([in] DiskId id);

    [notify=2]
    void DiskStateChanged([in] DiskId id, [in] DiskState state);
};
```


# 7. Code Generation Specification

## 7.1 Generated C++ Artifacts

For each service Foo:

-   Foo.h
-   Foo.cpp
-   Marshalling functions
-   Method dispatch table
-   Notification dispatch table

## 7.2 Generated Class Hierarchy

For each service `Foo`, the code generator SHALL produce:

### Server Side — `FooSkeleton` (abstract class)

``` cpp
class FooSkeleton {
public:
    FooSkeleton(const char* serviceName, RunLoop* dispatcher);

    // Generated — dispatches incoming request frames via switch/case
    // on methodId, unmarshals parameters, calls the virtual handler.
    int handleMessage(uint32_t methodId, const uint8_t* payload, ...);

    // Pure virtual — user implements these in a concrete subclass.
    virtual int handleGetDiskCount(uint32_t* count) = 0;
    virtual int handleGetDisks(uint32_t capacity,
                               DiskInfo* disks,
                               uint32_t* count) = 0;

    // Generated — notification senders (not virtual, not overridable).
    // Marshals parameters and broadcasts to all connected clients.
    void notifyDiskAdded(const DiskInfo& info);
    void notifyDiskRemoved(const DiskId& id);
    void notifyDiskStateChanged(const DiskId& id, DiskState state);
};
```

Usage:

``` cpp
class MyStorageService : public StorageServiceSkeleton {
    int handleGetDiskCount(uint32_t* count) override {
        *count = myDisks.size();
        return 0;
    }
    // ...
};

// Application code
RunLoop dispatcher;
MyStorageService impl("StorageService", &dispatcher);
Service::Create("StorageService", &impl);  // creates endpoint
dispatcher.run();  // blocks
```

### Client Side — `FooClient` (generated class)

``` cpp
class FooClient {
public:
    FooClient(const char* serviceName, RunLoop* dispatcher);

    void connect();  // blocks until server is available

    // Generated — marshals params, calls dispatcher.call(), unmarshals response
    int GetDiskCount(uint32_t* count);
    int GetDisks(uint32_t capacity, DiskInfo* disks, uint32_t* count);

    // Generated — dispatches incoming notification frames via switch/case
    int handleMessage(uint32_t notifyId, const uint8_t* payload, ...);

    // Virtual — user overrides to receive notifications
    virtual void onDiskAdded(const DiskInfo& info) {}
    virtual void onDiskRemoved(const DiskId& id) {}
    virtual void onDiskStateChanged(const DiskId& id, DiskState state) {}
};
```

Usage:

``` cpp
class MyStorageClient : public StorageServiceClient {
    void onDiskAdded(const DiskInfo& info) override {
        printf("New disk: %s\n", info.name);
    }
    // ...
};

// Application code
RunLoop dispatcher;
MyStorageClient client("StorageService", &dispatcher);
client.connect();  // blocks until server is available

std::thread t([&] { dispatcher.run(); });

uint32_t count;
client.GetDiskCount(&count);  // RPC call

dispatcher.stop();
t.join();
```

## 7.3 Server Skeleton Behavior

Server skeleton `handleMessage()` SHALL:

1.  Switch on `methodId`.
2.  Unmarshal request payload into parameters.
3.  Call the corresponding virtual handler.
4.  Marshal the return status and `[out]` parameters into response.
5.  Write response frame to shared memory ring buffer.
6.  Signal peer via UDS.

## 7.4 Client Stub Behavior

Client stub RPC methods (e.g., `GetDiskCount()`) SHALL:

1.  Marshal `[in]` parameters into request payload.
2.  Call `dispatcher.call(serviceId, methodId, request, response)`.
3.  Unmarshal response into `[out]` parameters.
4.  Return the status code.

Client stub `handleMessage()` SHALL:

1.  Switch on `notifyId`.
2.  Unmarshal notification payload into parameters.
3.  Call the corresponding virtual `on*()` callback.

------------------------------------------------------------------------

# 8. Python Binding Requirements

Python SHALL wrap generated C++ classes.

-   Python SHALL NOT implement transport logic.
-   Python SHALL call into C++ dispatcher.
-   Implementation SHOULD use pybind11.
-   Shared buffer semantics SHALL remain intact through C++ layer.

------------------------------------------------------------------------

# 9. Versioning Rules

-   Protocol version SHALL be encoded in header.
-   Version mismatch SHALL result in connection refusal.
-   Method IDs SHALL be stable once published.

------------------------------------------------------------------------

# 10. Build System

-   Build system: **CMake** (minimum 3.14)
-   C++ standard: **C++17**
-   Test framework: **Google Test (gtest)**
    -   Fetched via CMake `FetchContent` (no manual install required)
-   Tests SHALL be runnable via `ctest` and CI-compatible

------------------------------------------------------------------------

# 11. Testing Requirements

## 11.1 Implementation Order

The RunLoop runtime SHALL be implemented and tested first,
before the IDL parser and code generator. All tests below use the
RunLoop C++ API directly (no generated code).

## 11.2 RunLoop Unit Tests

### Ring Buffer Tests

1.  **Single write/read** — write one frame, read it back, verify
    contents match.
2.  **Multiple sequential writes** — write N frames, read N frames,
    verify order and contents.
3.  **Wraparound** — fill buffer past capacity boundary, verify
    correct wraparound behavior.
4.  **Full buffer** — write until ring buffer is full, verify
    `RPC_ERR_RING_FULL` returned.
5.  **Empty buffer read** — attempt read from empty buffer, verify
    no data returned.

### Connection Tests

6.  **Basic connection** — server creates endpoint, client connects,
    handshake completes.
7.  **Client before server** — client starts first, blocks, server
    starts later, connection established.
8.  **Multiple clients** — three clients connect to one server, each
    gets isolated connection.
9.  **Version mismatch** — client sends wrong protocol version, server
    sends NACK, connection refused.
10. **Connection cleanup** — client disconnects, server detects broken
    pipe, cleans up connection state.

### RPC Tests

11. **Basic RPC** — client sends request, server handles it, client
    receives response with correct status and data.
12. **RPC with payload** — request and response carry non-trivial
    payloads (multiple fields, various sizes).
13. **Concurrent RPC calls** — multiple threads on the client call
    `call()` simultaneously, all get correct responses (seq matching).
14. **RPC timeout** — server does not respond, client receives
    `RPC_ERR_TIMEOUT` (if timeout is implemented).
15. **RPC after disconnect** — server dies mid-call, client receives
    `RPC_ERR_DISCONNECTED`.

### Notification Tests

16. **Single notification** — server sends notification, client
    receives it with correct data.
17. **Broadcast notification** — server sends notification, all
    connected clients receive it.
18. **Notification with no clients** — server sends notification
    when no clients connected, no crash.
19. **Rapid notifications** — server sends many notifications
    quickly, client receives all in order.

### Dispatcher Lifecycle Tests

20. **run/stop** — `run()` blocks, `stop()` causes it to return.
21. **stop with pending calls** — `stop()` while RPC calls are
    in flight, pending calls complete with `RPC_ERR_STOPPED`.
22. **stop from signal handler** — `stop()` invoked from signal
    context (or simulated), dispatcher shuts down cleanly.
23. **Multiple services** — single RunLoop serves multiple
    service skeletons on different serviceIds.

### Crash / Error Handling Tests

24. **Server crash** — server process killed, client detects via
    broken pipe, receives `RPC_ERR_DISCONNECTED` on pending calls.
25. **Client crash** — client process killed, server detects via
    broken pipe, cleans up that client's connection.
26. **Ring buffer corruption guard** — malformed frame header in
    ring buffer, receiver handles gracefully without crash.

## 11.3 Integration Tests (Post Code Generator)

After the IDL parser and code generator are implemented:

1.  End-to-end with generated StorageService stubs.
2.  Multi-client notification delivery with generated code.
3.  All IDL data types (scalars, enums, structs, arrays, strings).

------------------------------------------------------------------------

End of Formal Specification
